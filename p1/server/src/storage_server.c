/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

#include "storage.h"

bool_t
init_1_svc(int *result, struct svc_req *rqstp)
{
	bool_t retval;

        *result = system("exec mkdir -p database"); 
        if (*result != -1) *result = system("exec rm -r database/*");

	retval = TRUE;

	return retval;
}

bool_t
insert_1_svc(char *sender, char *receiver, char *id, char *msg, char *md5, int *result,  struct svc_req *rqstp)
{
	bool_t retval;
	int ret;

	int name_size = strlen("database/") + strlen(sender);
	int line_size = strlen(receiver) + strlen(id) + strlen(msg) + strlen(md5) + 4;
	char file_name[name_size];
	char line[line_size];

	sprintf(file_name, "database/%s", sender);
	sprintf(line, "%s,%s,%s,%s\n", id, receiver, msg, md5);

	int fd;
	int written = 0, to_write = line_size;

	if ((fd = open(file_name, O_WRONLY|O_CREAT|O_APPEND, 0666)) == -1) {
		*result = -1;
		return FALSE;
	}

	while (to_write > 0 && written >=0) {
		written = write(fd, (char *) line + (line_size - to_write), to_write);
		to_write -= written;
	}

	if (written == -1) *result = -1; // Error on write
	else *result = 0;

	close(fd);

	retval = TRUE;

	return retval;
}

bool_t
msg_n_1_svc(char *sender, int *result,  struct svc_req *rqstp)
{
	bool_t retval;
	int fd, last_read, lines = 0, name_size = strlen("database/") + strlen(sender);
	char buffer = 32, file_name[name_size];

	sprintf(file_name, "database/%s", sender);

	if ((fd = open(file_name, O_RDONLY)) == -1) return FALSE;

	while (buffer != EOF && (last_read = read(fd, &buffer, 1)) >= 0) {
		if (last_read == 0) continue; // No se ha leido nada, probar otra vez.

		if (buffer == '\n') lines++;
	}

	close(fd);

	return retval;
}

bool_t
query_1_svc(char *user, char *id, query_msg *result,  struct svc_req *rqstp)
{
	bool_t retval;

	int fd, attr_n = 0, found = 0, last_read, idx = 0, name_size = strlen("database/") + strlen(user);
	char buffer = 32, file_name[name_size], field[256];

	sprintf(file_name, "database/%s", user);
	bzero(field, 256);


	if ((fd = open(file_name, O_RDONLY)) == -1) return FALSE;

	while ((last_read = read(fd, &buffer, 1)) >= 0) {
		if (buffer == EOF) break;
		if (last_read == 0) continue; // No se ha leido nada, probar otra vez.

		if (buffer == ',') {
			if (attr_n == 0 && !strcmp(field, id)) found = 1;
			if (attr_n == 2 && found) {
				result->msg = malloc(strlen(field));
				strcpy(result->msg, field);
			}
			bzero(field, 256);
			attr_n++;
			idx = 0;
			continue;
		} else if (buffer == '\n') {
			if (found) {
				result->md5 = malloc(strlen(field));
				strcpy(result->md5, field);
				break;
			}
			bzero(field, 256);
			attr_n = 0;
			idx = 0;
			continue;
		}

		field[idx] = buffer;
		idx ++;
	}

	if (!found) {
		result->msg = "";
		result->md5 = "";
	}
	close(fd);
	retval = TRUE;

	return retval;
}

int
msg_store_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
