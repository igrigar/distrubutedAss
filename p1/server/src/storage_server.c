/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

#include "storage.h"

bool_t
init_1_svc(int *result, struct svc_req *rqstp)
{
	bool_t retval;

	char *command1[4] = {"mkdir", "-p", "database", NULL};
	char *command2[4] = {"rm", "-rf", "database/*", NULL};

	int ret = 0;
	pid_t rm_proc = fork();

	// Creating if needed the directory.
	switch (rm_proc) {
		case 0: // Child
			if (execvp(command1[0], command1) == -1) {
				ret = -1;
				perror("Error execvp");
			}
			break;
		case -1: // Error
			ret = -1;
			perror("Error in fork");
			break;
		default: // Parent
			if (wait(0) == -1) {
				perror("Error child process");
				ret = -1;
			}
	}

	rm_proc = fork();
	// Removing all the stuff in the database.
	switch (rm_proc) {
		case 0: // Child
			if (execvp(command2[0], command2) == -1) {
				ret = -1;
				perror("Error execvp");
			}
			break;
		case -1: // Error
			ret = -1;
			perror("Error in fork");
			break;
		default: // Parent
			if (wait(0) == -1) {
				perror("Error child process");
				ret = -1;
			}
	}

	retval = TRUE;
	*result = ret;

	return retval;
}

bool_t
insert_1_svc(char *sender, char *receiver, char *id, char *msg, char *md5, int *result,  struct svc_req *rqstp)
{
	bool_t retval;
	int ret;

	int name_size = strlen("database/") + strlen(sender);
	int line_size = strlen(receiver) + strlen(id) + strlen(msg) + strlen(md5) + 4;
	char file_name[name_size];
	char line[line_size];

	sprintf(file_name, "database/%s", sender);
	sprintf(line, "%s,%s,%s,%s\n", id, receiver, msg, md5);

	int fd;
	int written = 0, to_write = line_size;

	if ((fd = open(file_name, O_WRONLY|O_CREAT|O_APPEND, 0666)) == -1) {
		*result = -1;
		return FALSE;
	}

	while (to_write > 0 && written >=0) {
		written = write(fd, (char *) line + (line_size - to_write), to_write);
		to_write -= written;
	}

	if (written == -1) *result = -1; // Error on write
	else *result = 0;

	close(fd);

	retval = TRUE;

	return retval;
}

bool_t
msg_n_1_svc(char *sender, int *result,  struct svc_req *rqstp)
{
	bool_t retval;
	int fd, last_read, lines = 0, name_size = strlen("database/") + strlen(user);
	char buffer = 32;

	sprintf(file_name, "database/%s", user);

	if ((fd = open(file_name, O_RDONLY)) == -1) return FALSE;

	while (buffer != EOF && (last_read = read(fd, &buffer, 1)) >= 0) {
		if (last_read == 0) continue; // No se ha leido nada, probar otra vez.

		if (buffer == '\n') lines++;
	}

	close(fd);

	return retval;
}

bool_t
query_1_svc(char *user, char *id, query_msg *result,  struct svc_req *rqstp)
{
	bool_t retval;

	int fd, readed, attr_n = 0, found = 0, last_read, idx = 0, name_size = strlen("database/") + strlen(user);
	char buffer = 32, file_name[name_size], field[256];

	sprintf(file_name, "database/%s", user);
	bzero(field, 256);

	result->msg = "";
	result->md5 = "";

	if ((fd = open(file_name, O_RDONLY)) == -1) return FALSE;

	while (buffer != EOF && (last_read = read(fd, &buffer, 1)) >= 0) {
		if (last_read == 0) continue; // No se ha leido nada, probar otra vez.

		if (buffer == ',') {
			if (attr_n == 0 && !strcmp(field, id)) found = 1;
			if (attr_n == 2 && found) strcpy(result->msg, field);
			bzero(field, 256);
			attr_n++;
			idx = 0;
			continue;
		} else if (buffer == '\n') {
			if (found) {
				strcpy(result->md5, field);
				break;
			}
			bzero(field, 256);
			attr_n = 0;
			idx = 0;
			continue;
		}

		field[idx] = buffer;
		idx ++;
	}

	close(fd);
	retval = TRUE;

	return retval;
}

int
msg_store_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
